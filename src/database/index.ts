// ==================================================
// 外部ライブラリのインポート（外部から機能を借りてくる）
// ==================================================

// sqlite3: SQLiteデータベースの基本ドライバー
// - SQLiteとは軽量なファイル型データベース
// - アプリケーションに組み込み可能
// - サーバー不要でローカルファイルにデータを保存
// 例: ユーザー設定、キャッシュデータの永続化
import sqlite3 from 'sqlite3';

// sqlite: SQLiteの高レベルAPI（sqlite3をより使いやすくしたライブラリ）
// - open: データベース接続を開く関数
// - Database: データベース操作のためのインターフェース
// より直感的なPromise/async-awaitの使用が可能
import { open, Database } from 'sqlite';

// ==================================================
// 自分で作ったファイルのインポート
// ==================================================

// ログ出力を管理するユーティリティ関数
// console.logより高機能で、ファイルに保存したりレベル分けができる
import { createLogger } from '../utils/logger';

// TypeScript型定義のインポート
// プログラミング初心者向け説明:
// - DatabaseError: データベース関連のエラーを表すクラス
import { DatabaseError } from '../types/index';

// Node.js標準ライブラリのインポート
// fs: ファイルシステム操作のためのライブラリ
// - ファイル・ディレクトリの作成、削除、読み書き
// - 存在確認、統計情報の取得
import fs from 'fs';

// path: ファイルパス操作のためのライブラリ
// - パスの結合、分離、正規化
// - OS（Windows/Mac/Linux）に依存しないパス操作
import path from 'path';

// ==================================================
// ログシステムの初期化
// ==================================================

/**
 * このファイル専用のログ出力システムを作成
 *
 * 【ロガーとは？】
 * console.logの高機能版。以下の機能がある：
 * - ファイル識別: どのファイルからのログかを記録
 * - レベル分け: info（情報）, warn（警告）, error（エラー）など
 * - ファイル保存: ログをファイルに自動保存
 * - タイムスタンプ: いつのログかを記録
 *
 * 'database' は このファイルの識別名
 */
const logger = createLogger('database');

// ==================================================
// データベースマネージャークラスの定義
// ==================================================

/**
 * データベースマネージャークラス - SQLiteデータベースの操作を管理
 *
 * 【このクラスの役割】
 * 1. SQLiteデータベースへの接続・切断
 * 2. データベーススキーマの初期化
 * 3. パフォーマンス最適化設定
 * 4. ヘルスチェックと統計情報の提供
 * 5. メンテナンス操作（VACUUM、期限切れデータクリーンアップ）
 *
 * 【SQLiteとは？】
 * - ファイルベースの軽量データベース
 * - サーバー不要（アプリケーションに組み込み可能）
 * - ACIDトランザクション対応
 * - SQLクエリの標準的なサポート
 *
 * 【export とは？】
 * このクラスを他のファイルから使えるように公開する
 * 他のファイルから import できるようになる
 *
 * 【class とは？】
 * オブジェクト指向プログラミングの基本概念
 * データ（プロパティ）と機能（メソッド）をまとめた設計図
 * 実際の道具（インスタンス）を作るための型枠
 *
 * 【なぜクラスを使うのか？】
 * - 関連する機能をまとめて管理
 * - コードの再利用性向上
 * - メンテナンスの容易さ
 * - データの安全性（カプセル化）
 */
export class DatabaseManager {
  /**
   * プライベートプロパティ（クラス内部でのみ使用）
   *
   * 【private とは？】
   * クラスの外部からは直接アクセスできない内部変数
   * データの安全性を保つためのカプセル化
   * 例: manager.db = null のような変更を防ぐ
   */

  /**
   * SQLiteデータベース接続オブジェクト
   *
   * 【Database | null 型とは？】
   * Database型またはnullのどちらかを受け入れる型
   * - Database: 接続が確立されている状態
   * - null: 未接続または接続が閉じられている状態
   *
   * 【初期値null の理由】
   * コンストラクタ実行時点ではまだデータベースに接続していない
   * initialize()メソッドで実際の接続を確立する
   */
  private db: Database | null = null;

  /**
   * データベースファイルのパス
   *
   * 【string型とは？】
   * 文字列を格納する基本的なデータ型
   * 例: './data/bot.db' や ':memory:'
   *
   * 【パスの種類】
   * - ファイルパス: './data/bot.db' のような実際のファイル
   * - インメモリ: ':memory:' の特殊値（メモリ上のDB）
   */
  private dbPath: string;

  /**
   * コンストラクタ - クラスのインスタンス作成時に実行される初期化処理
   *
   * 【コンストラクタとは？】
   * new DatabaseManager() でオブジェクトを作成する際に自動実行される関数
   * オブジェクトの初期設定を行う
   *
   * 【引数のデフォルト値 とは？】
   * 引数が省略された場合に使用される値
   * dbPath: string = './data/bot.db'
   * → dbPathが指定されない場合、'./data/bot.db'を使用
   *
   * 【デフォルトパスの選択理由】
   * './data/bot.db' は一般的なデータ保存場所
   * プロジェクトルートからの相対パス
   *
   * @param dbPath - データベースファイルのパス、省略時はデフォルト値を使用
   */
  constructor(dbPath: string = './data/bot.db') {
    /**
     * 本番環境でのデータベース設定の自動切り替え
     *
     * 【環境変数とは？】
     * アプリケーションの設定値を外部から指定する仕組み
     * コードを変更せずに動作を変えられる
     *
     * 【process.env とは？】
     * Node.jsで環境変数にアクセスするためのオブジェクト
     * 例: process.env.NODE_ENV → 'production' や 'development'
     *
     * 【|| 演算子（論理OR）とは？】
     * 左側が true の場合は左側を、false の場合は右側を評価
     * ここでは「Railway環境」または「本番環境」のどちらかが true の場合
     *
     * 【Railway環境とは？】
     * Railway.app というクラウドホスティングサービス
     * RAILWAY_ENVIRONMENT 環境変数が自動設定される
     *
     * 【NODE_ENV === 'production' とは？】
     * Node.jsの標準的な本番環境識別方法
     * 本番環境では 'production'、開発環境では 'development' が設定される
     */
    if (process.env.RAILWAY_ENVIRONMENT || process.env.NODE_ENV === 'production') {
      /**
       * 本番環境でインメモリデータベースを使用
       *
       * 【':memory:' とは？】
       * SQLiteの特殊なファイル名
       * ファイルではなくメモリ上にデータベースを作成
       *
       * 【なぜ本番環境でインメモリDB？】
       * - クラウド環境ではファイルの永続化が困難
       * - 一時的なキャッシュ用途のため、永続化不要
       * - メモリの方が高速でパフォーマンスが良い
       *
       * 【this.dbPath = とは？】
       * このクラスインスタンスのdbPathプロパティに値を代入
       * クラス内の他のメソッドから this.dbPath でアクセス可能
       */
      this.dbPath = ':memory:';

      /**
       * ログ出力で設定変更を記録
       *
       * 【logger.info() とは？】
       * 情報レベルのログを出力する関数
       * 運用時の状態確認に重要
       *
       * 【なぜログ出力？】
       * - 運用監視: どの環境設定で動作しているか確認
       * - デバッグ: 問題発生時の設定状態把握
       * - 設定ミスの早期発見
       */
      logger.info('Using in-memory database for production environment');
    } else {
      /**
       * 開発環境では指定されたファイルパスを使用
       *
       * 【開発環境の特徴】
       * - データの永続化が必要（開発中のデータ保持）
       * - ファイルシステムへの書き込みが可能
       * - デバッグ時にDBファイルを直接確認できる
       *
       * 【this.dbPath = dbPath の意味】
       * コンストラクタの引数で指定されたパス、
       * または デフォルト値 './data/bot.db' を使用
       */
      this.dbPath = dbPath;
    }
  }

  /**
   * データベースの初期化処理
   *
   * 【このメソッドの役割】
   * 1. データベースディレクトリの作成
   * 2. SQLiteデータベースへの接続
   * 3. テーブル構造（スキーマ）の初期化
   * 4. パフォーマンス最適化設定の適用
   *
   * 【async/await とは？】
   * 時間のかかる処理（ファイル操作、DB接続など）を扱うための仕組み
   * - async: この関数は非同期処理を含むことを宣言
   * - await: 処理の完了を待つキーワード
   *
   * 【Promise<void> とは？】
   * - Promise: 非同期処理の結果を表すオブジェクト
   * - void: 戻り値がないことを表すTypeScript型
   * - つまり「非同期で実行され、戻り値のない関数」という意味
   *
   * 【なぜ非同期処理？】
   * ファイル操作やデータベース接続は時間がかかるため、
   * 他の処理をブロックしないよう非同期で実行
   */
  async initialize(): Promise<void> {
    /**
     * エラーハンドリング（エラー処理）のためのtry-catch文
     *
     * 【try-catch とは？】
     * エラーが発生する可能性のある処理を安全に実行する仕組み
     * - try: エラーが発生するかもしれない処理を書く
     * - catch: エラーが発生した場合の対処を書く
     */
    try {
      /**
       * データベースディレクトリの作成（ファイルDB用）
       *
       * 【なぜディレクトリ作成が必要？】
       * SQLiteファイルを保存するディレクトリが存在しない場合、
       * データベース作成時にエラーになるため事前に作成
       */

      /**
       * インメモリDBかファイルDBかの判定
       *
       * 【!== 演算子 とは？】
       * 厳密不等価演算子
       * 型と値の両方が異なる場合に true を返す
       * ここでは「インメモリDBではない」場合を判定
       *
       * 【条件分岐の意味】
       * インメモリDB（':memory:'）の場合はファイル不要のため、
       * ディレクトリ作成処理をスキップ
       */
      if (this.dbPath !== ':memory:') {
        /**
         * データベースファイルの親ディレクトリを取得
         *
         * 【path.dirname() とは？】
         * ファイルパスから親ディレクトリのパスを抽出する関数
         * 例: './data/bot.db' → './data'
         *
         * 【const vs let の使い分け】
         * dbDirは一度取得したら変更しないため const を使用
         */
        const dbDir = path.dirname(this.dbPath);

        /**
         * ディレクトリの存在確認と作成
         *
         * 【fs.existsSync() とは？】
         * ファイル・ディレクトリが存在するかを同期的にチェックする関数
         * 存在する場合 true、存在しない場合 false を返す
         *
         * 【! 演算子（論理NOT）とは？】
         * 値を反転させる演算子
         * !true = false, !false = true
         * ここでは「ディレクトリが存在しない」をチェック
         */
        if (!fs.existsSync(dbDir)) {
          /**
           * ディレクトリを再帰的に作成
           *
           * 【fs.mkdirSync() とは？】
           * ディレクトリを同期的に作成する関数
           *
           * 【{ recursive: true } とは？】
           * recursive（再帰的）オプション
           * 親ディレクトリが存在しない場合も含めて、
           * 必要なディレクトリを全て作成する
           * 例: './data/cache/temp' → data、cache、temp を順次作成
           *
           * 【なぜrecursive: true？】
           * プロジェクトの初回実行時にディレクトリ構造が存在しない場合、
           * 一度に全ての必要なディレクトリを作成するため
           */
          fs.mkdirSync(dbDir, { recursive: true });

          /**
           * ディレクトリ作成の成功をログ出力
           *
           * 【テンプレートリテラル記法】
           * `文字列 ${変数} 文字列` でログメッセージを作成
           * より読みやすく、エラーが少ない文字列結合方法
           */
          logger.info(`Created database directory: ${dbDir}`);
        }
      }

      /**
       * SQLiteデータベースへの接続確立
       *
       * 【open() 関数とは？】
       * sqlite ライブラリの関数でデータベース接続を開く
       * Promise を返すため await で完了を待つ
       */
      this.db = await open({
        /**
         * filename: データベースファイルのパス
         *
         * 【設定値の説明】
         * - ファイルパス: './data/bot.db' のような実際のファイル
         * - インメモリ: ':memory:' でメモリ上にDB作成
         */
        filename: this.dbPath,

        /**
         * driver: SQLiteドライバーの指定
         *
         * 【sqlite3.Database とは？】
         * sqlite3ライブラリの基本ドライバークラス
         * 実際のSQLite操作を行う低レベルAPI
         */
        driver: sqlite3.Database,
      });

      /**
       * 接続成功をログ出力
       *
       * 【重要性】
       * - 運用監視: データベース接続の成功確認
       * - デバッグ: 接続先パスの確認
       * - トラブルシューティング: 接続問題の切り分け
       */
      logger.info(`Database connected: ${this.dbPath}`);

      /**
       * データベーススキーマの初期化
       *
       * 【スキーマとは？】
       * データベースの構造定義（テーブル、カラム、インデックスなど）
       * アプリケーションが必要とするテーブル構造を作成
       *
       * 【await の必要性】
       * スキーマ作成が完了してから次の処理に進む必要があるため
       */
      await this.initializeSchema();

      /**
       * データベースのパフォーマンス最適化
       *
       * 【最適化とは？】
       * SQLiteの設定を調整してパフォーマンスを向上させる
       * 例: WALモード、キャッシュサイズ、同期設定
       */
      await this.optimizeDatabase();

      /**
       * 初期化完了の確認ログ
       *
       * 【なぜ完了ログ？】
       * 全ての初期化処理が正常に完了したことを確認
       * 運用時の健全性チェックで重要
       */
      logger.info('Database initialization completed');

      /**
       * エラーハンドリング（エラー処理）
       *
       * 【catch ブロックの役割】
       * initialize メソッド内で発生したエラーを捕捉
       * ログ出力後にカスタムエラーとして再投げ
       */
    } catch (error) {
      /**
       * エラーログの出力
       *
       * 【logger.error() とは？】
       * エラーレベルのログを出力する関数
       * 問題の原因調査に重要な情報を記録
       */
      logger.error('Database initialization failed:', error);

      /**
       * カスタムエラーとして再投げ
       *
       * 【throw new DatabaseError() とは？】
       * 汎用エラーではなく、データベース専用のエラーオブジェクトを作成
       * エラーの種類を明確にし、上位レイヤーでの適切な処理を可能にする
       *
       * 【なぜ再投げ？】
       * このメソッドを呼び出した側でもエラー処理が必要
       * ログ出力だけでなく、アプリケーション全体にエラーを通知
       */
      throw new DatabaseError('Failed to initialize database', error);
    }
  }

  /**
   * データベーススキーマの初期化
   *
   * 【このメソッドの役割】
   * 1. スキーマファイル（schema.sql）の読み込み
   * 2. SQLコマンドの実行によるテーブル作成
   * 3. インデックスや制約の設定
   *
   * 【private とは？】
   * クラス内部でのみ使用されるメソッド
   * 外部から直接呼び出すことはできない
   *
   * 【スキーマとは？】
   * データベースの構造定義（テーブル、カラム、インデックスなど）
   * アプリケーションが必要とするデータ構造の設計図
   */
  private async initializeSchema(): Promise<void> {
    try {
      /**
       * スキーマファイルのパスを構築
       *
       * 【path.join() とは？】
       * 複数のパス要素を結合して完全なパスを作成する関数
       * OS固有のパス区切り文字（\ または /）を自動で使用
       *
       * 【__dirname とは？】
       * 現在のファイルが存在するディレクトリの絶対パス
       * Node.jsの特殊変数
       *
       * 【'schema.sql' とは？】
       * テーブル作成のSQLコマンドが書かれたファイル
       * CREATE TABLE文、インデックス作成文などを含む
       */
      const schemaPath = path.join(__dirname, 'schema.sql');

      /**
       * スキーマファイルの内容を読み込み
       *
       * 【fs.readFileSync() とは？】
       * ファイルの内容を同期的に読み込む関数
       * 処理をブロックして確実にファイルを読み込む
       *
       * 【'utf8' とは？】
       * 文字エンコーディングの指定
       * UTF-8形式でファイルを文字列として読み込む
       *
       * 【なぜ同期読み込み？】
       * スキーマファイルは小さく、初期化処理でのみ使用
       * 確実にファイルが読み込まれてから次の処理に進む必要がある
       */
      const schema = fs.readFileSync(schemaPath, 'utf8');

      /**
       * スキーマSQLの実行
       *
       * 【this.db!.exec() とは？】
       * - this.db: クラスのデータベース接続オブジェクト
       * - !: TypeScriptの非nullアサーション演算子（this.dbがnullでないことを保証）
       * - exec(): 複数のSQLコマンドを一度に実行する関数
       *
       * 【await の必要性】
       * SQLコマンドの実行は時間がかかる可能性があるため、
       * 完了を待ってから次の処理に進む
       *
       * 【なぜexec()？】
       * schema.sqlには複数のCREATE TABLE文が含まれるため、
       * 一度に全て実行できるexec()を使用
       */
      await this.db!.exec(schema);

      /**
       * スキーマ初期化の成功をログ出力
       *
       * 【なぜログ出力？】
       * - 初期化処理の進行状況確認
       * - テーブル作成の成功確認
       * - デバッグ時の処理フロー把握
       */
      logger.info('Database schema initialized');

      /**
       * エラーハンドリング（エラー処理）
       */
    } catch (error) {
      /**
       * エラーログの出力
       *
       * 【考えられるエラー】
       * - schema.sqlファイルが見つからない
       * - SQLコマンドに構文エラーがある
       * - データベース接続が失われている
       */
      logger.error('Schema initialization failed:', error);

      /**
       * カスタムエラーとして再投げ
       *
       * 【DatabaseError の意義】
       * 汎用エラーではなく、データベース専用のエラーを作成
       * 上位レイヤーでエラーの種類を判別しやすくする
       */
      throw new DatabaseError('Failed to initialize database schema', error);
    }
  }

  /**
   * データベースのパフォーマンス最適化設定
   *
   * 【このメソッドの役割】
   * SQLiteの各種設定を調整してパフォーマンスを向上させる
   * 1. WALモードの有効化（並行アクセス改善）
   * 2. 外部キー制約の有効化（データ整合性確保）
   * 3. 同期設定の最適化（安全性とパフォーマンスのバランス）
   * 4. キャッシュサイズの設定（メモリ使用量の最適化）
   *
   * 【PRAGMAとは？】
   * SQLiteの設定を変更するための特殊なSQLコマンド
   * データベースの動作を細かく制御できる
   */
  private async optimizeDatabase(): Promise<void> {
    try {
      /**
       * WALモード（Write-Ahead Logging）の有効化
       *
       * 【WALモードとは？】
       * - Write-Ahead Logging: 書き込み先行ログ方式
       * - 書き込み処理を専用ログファイルに記録
       * - 読み込み処理をブロックしない並行処理が可能
       *
       * 【従来のモードとの違い】
       * - DELETE mode: 読み書きが排他的（同時実行不可）
       * - WAL mode: 複数の読み込みと1つの書き込みが同時実行可能
       *
       * 【メリット】
       * - 読み込み性能の向上
       * - アプリケーションの応答性改善
       * - デッドロックの減少
       *
       * 【デメリット】
       * - ディスク使用量の増加（WALファイル）
       * - 定期的なチェックポイント処理が必要
       */
      await this.db!.exec('PRAGMA journal_mode = WAL');

      /**
       * 外部キー制約の有効化
       *
       * 【外部キー制約とは？】
       * テーブル間のリレーション（関連性）を強制する仕組み
       * 例: issuesテーブルのrepository_idは必ずrepositoriesテーブルに存在する値
       *
       * 【SQLiteのデフォルト】
       * 外部キー制約は無効（PRAGMA foreign_keys = OFF）
       * パフォーマンス重視のため
       *
       * 【有効化する理由】
       * - データ整合性の確保
       * - 不正なデータの挿入防止
       * - 参照先が削除された場合の適切な処理
       *
       * 【具体例】
       * 存在しないリポジトリIDでIssue情報を保存しようとした場合、
       * エラーが発生して不整合なデータの作成を防ぐ
       */
      await this.db!.exec('PRAGMA foreign_keys = ON');

      /**
       * 同期設定の最適化
       *
       * 【synchronous設定とは？】
       * SQLiteがデータをディスクに書き込む際の安全性レベル
       *
       * 【設定値の意味】
       * - OFF (0): 同期なし（最高速、データ損失リスク大）
       * - NORMAL (1): 重要な時点のみ同期（バランス型）
       * - FULL (2): 常時同期（最安全、低速）
       *
       * 【NORMAL選択の理由】
       * - パフォーマンスと安全性のバランス
       * - システムクラッシュ時のデータ損失を最小限に
       * - 通常のアプリケーション停止では影響なし
       *
       * 【具体的な動作】
       * データベースの重要な更新（トランザクション完了）時のみ
       * ディスクへの強制書き込みを実行
       */
      await this.db!.exec('PRAGMA synchronous = NORMAL');

      /**
       * キャッシュサイズの設定
       *
       * 【cache_sizeとは？】
       * SQLiteがメモリに保持するデータベースページ数
       * 1ページ = 通常4096バイト（4KB）
       *
       * 【10000ページの意味】
       * 10000 × 4KB = 約40MB のメモリキャッシュ
       *
       * 【キャッシュの効果】
       * - 頻繁にアクセスされるデータをメモリに保持
       * - ディスクアクセスの削減による高速化
       * - 特に読み込み性能の大幅向上
       *
       * 【サイズ選択の考慮事項】
       * - 大きすぎる: メモリ使用量の増加
       * - 小さすぎる: キャッシュ効果の低下
       * - 40MBは一般的なアプリケーションで適切なサイズ
       *
       * 【負の値の意味】
       * 正数: ページ数指定
       * 負数: KB単位でのサイズ指定（例: -40000 = 40MB）
       */
      await this.db!.exec('PRAGMA cache_size = 10000');

      /**
       * 最適化完了の確認ログ
       *
       * 【なぜ確認ログ？】
       * - 全ての最適化設定が正常に適用された確認
       * - 運用時のパフォーマンス設定状態の把握
       * - 設定の適用順序確認（他の設定に依存する場合）
       */
      logger.info('Database optimization completed');

      /**
       * エラーハンドリング（エラー処理）
       */
    } catch (error) {
      /**
       * エラーログの出力
       *
       * 【最適化エラーの影響】
       * データベースは動作するが、パフォーマンスが低下
       * 致命的ではないが、運用に影響する可能性
       */
      logger.error('Database optimization failed:', error);

      /**
       * カスタムエラーとして再投げ
       *
       * 【エラー処理の選択肢】
       * 1. エラーを投げる（現在の実装）: 初期化を失敗させる
       * 2. 警告ログのみ: 最適化なしで動作継続
       *
       * 【現在の実装理由】
       * 最適化は重要な設定のため、失敗時は明確にエラーとする
       */
      throw new DatabaseError('Failed to optimize database', error);
    }
  }

  /**
   * データベース接続オブジェクトを取得
   *
   * 【このメソッドの役割】
   * データベース接続を確実に取得するためのゲッターメソッド
   * 未初期化の場合は自動的に初期化を実行
   *
   * 【Lazy Initialization パターン】
   * オブジェクトの作成を実際に必要になるまで遅延させる設計パターン
   * メモリ使用量の削減とアプリケーション起動時間の短縮
   *
   * 【Promise<Database> とは？】
   * - Promise: 非同期処理の結果を表すオブジェクト
   * - Database: SQLiteデータベース接続の型
   * - つまり「非同期でDatabase型を返す関数」という意味
   */
  async getDatabase(): Promise<Database> {
    /**
     * データベース接続の状態チェック
     *
     * 【! 演算子（論理NOT）とは？】
     * 値を反転させる演算子
     * !this.db → this.dbがnull/undefinedの場合にtrue
     *
     * 【なぜnullチェック？】
     * コンストラクタでは接続を確立せず、
     * 初回アクセス時に遅延初期化を実行するため
     */
    if (!this.db) {
      /**
       * 未初期化の場合、自動的に初期化実行
       *
       * 【await の必要性】
       * 初期化処理は非同期（ファイル操作、DB接続）のため、
       * 完了を待ってからデータベースオブジェクトを返す
       *
       * 【initialize() の内容】
       * 1. ディレクトリ作成
       * 2. データベース接続
       * 3. スキーマ初期化
       * 4. パフォーマンス最適化
       */
      await this.initialize();
    }

    /**
     * 初期化済みデータベース接続を返却
     *
     * 【this.db! とは？】
     * - this.db: クラスのデータベース接続プロパティ
     * - !: TypeScriptの非nullアサーション演算子
     *
     * 【非nullアサーション演算子とは？】
     * TypeScriptコンパイラに「この値はnullではない」と保証する記号
     * 上記のif文で初期化を保証しているため、nullの可能性はない
     *
     * 【なぜ必要？】
     * TypeScriptの型システムは上記の初期化を理解できないため、
     * 明示的にnullでないことを示す必要がある
     */
    return this.db!;
  }

  /**
   * データベース接続を閉じる
   *
   * 【このメソッドの役割】
   * 1. データベース接続の適切な終了
   * 2. リソースの解放
   * 3. メモリリークの防止
   *
   * 【なぜ明示的なclose()が必要？】
   * - ファイルハンドルの適切な解放
   * - WALファイルの適切な処理
   * - 他のプロセスからのアクセス許可
   *
   * 【呼び出しタイミング】
   * - アプリケーション終了時
   * - 長時間の非アクティブ期間
   * - エラー発生時の復旧処理
   */
  async close(): Promise<void> {
    /**
     * 接続状態の確認
     *
     * 【なぜnullチェック？】
     * 未初期化または既にclose済みの場合は処理をスキップ
     * 重複したclose()呼び出しを安全に処理
     */
    if (this.db) {
      /**
       * データベース接続の終了
       *
       * 【db.close() の処理内容】
       * - 開いているトランザクションのコミット/ロールバック
       * - ファイルハンドルの解放
       * - WALファイルのチェックポイント実行
       * - メモリキャッシュのフラッシュ
       *
       * 【await の必要性】
       * 接続終了処理が完了してから次の処理に進む
       * 不完全な終了処理によるデータ破損を防ぐ
       */
      await this.db.close();

      /**
       * 接続オブジェクトをnullに設定
       *
       * 【なぜnullを代入？】
       * - メモリリークの防止
       * - 再利用時の初期化フラグとして機能
       * - 閉じられた接続の誤用防止
       */
      this.db = null;

      /**
       * 接続終了の確認ログ
       *
       * 【ログの重要性】
       * - 正常な終了処理の確認
       * - リソース管理の監査
       * - デバッグ時の処理フロー把握
       */
      logger.info('Database connection closed');
    }
  }

  /**
   * データベース接続の健全性チェック
   *
   * 【このメソッドの役割】
   * 1. データベース接続が生きているかの確認
   * 2. SQLクエリが正常に実行できるかのテスト
   * 3. 運用監視での自動ヘルスチェック
   *
   * 【ヘルスチェックとは？】
   * システムの正常動作を定期的に確認する仕組み
   * 問題の早期発見とサービス可用性の維持に重要
   *
   * 【戻り値の意味】
   * - true: データベースは正常に動作中
   * - false: データベースに問題がある、または未初期化
   */
  async healthCheck(): Promise<boolean> {
    try {
      /**
       * 初期化状態の確認
       *
       * 【未初期化の場合の処理】
       * false を返してヘルスチェック失敗を示す
       * 初期化されていないデータベースは「不健全」と判定
       */
      if (!this.db) {
        return false;
      }

      /**
       * 簡単なSQLクエリで接続をテスト
       *
       * 【SELECT 1 as test とは？】
       * - SELECT 1: 単純な定数を選択するSQL
       * - as test: 結果のカラム名を「test」として別名定義
       * - データベースエンジンへの最小限の負荷でテスト実行
       *
       * 【なぜSELECT 1？】
       * - 実際のテーブルアクセス不要
       * - 高速実行（I/O処理なし）
       * - SQLエンジンの基本動作確認に最適
       */
      const result = await this.db.get('SELECT 1 as test');

      /**
       * クエリ結果の検証
       *
       * 【&& 演算子（論理AND）とは？】
       * 左側と右側の両方が true の場合のみ true を返す
       * 左側が false の場合、右側は評価されない（ショートサーキット）
       *
       * 【result && result.test === 1 の意味】
       * 1. result: クエリ結果オブジェクトが存在するか
       * 2. result.test === 1: test カラムの値が期待値（1）かチェック
       *
       * 【期待される結果】
       * result = { test: 1 } の形式のオブジェクト
       */
      return result && result.test === 1;

      /**
       * エラーハンドリング
       */
    } catch (error) {
      /**
       * ヘルスチェック失敗のログ出力
       *
       * 【考えられるエラー原因】
       * - ネットワーク接続の問題
       * - データベースファイルの破損
       * - リソース不足（メモリ、ディスク）
       * - SQLiteエンジンの問題
       */
      logger.error('Database health check failed:', error);

      /**
       * エラー時は不健全として false を返す
       *
       * 【なぜ例外を投げない？】
       * ヘルスチェックは監視用途のため、エラーでも結果（false）を返す
       * 呼び出し元でエラーハンドリングを強制しない設計
       */
      return false;
    }
  }

  /**
   * データベースのVACUUM操作を実行
   *
   * 【VACUUMとは？】
   * SQLiteデータベースの最適化・メンテナンス操作
   * 1. 削除されたデータの物理的な除去
   * 2. データベースファイルサイズの縮小
   * 3. インデックスの再構築と最適化
   * 4. フラグメンテーション（断片化）の解消
   *
   * 【実行タイミング】
   * - 大量のデータ削除後
   * - 定期メンテナンス時
   * - ディスク容量節約が必要な時
   *
   * 【注意点】
   * - 処理時間が長い（データベースサイズに比例）
   * - 実行中は他の操作をブロック
   * - 一時的に2倍のディスク容量が必要
   */
  async vacuum(): Promise<void> {
    try {
      /**
       * 初期化状態の確認
       *
       * 【なぜ例外を投げる？】
       * VACUUMは明示的なメンテナンス操作のため、
       * 未初期化は明確にエラーとして扱う
       */
      if (!this.db) {
        throw new DatabaseError('Database not initialized');
      }

      /**
       * VACUUM操作の実行
       *
       * 【VACUUM SQLコマンド】
       * SQLiteの標準コマンドでデータベース全体を最適化
       * 内部的に以下の処理を実行:
       * 1. 新しい一時データベースファイルを作成
       * 2. 全てのデータを新ファイルに最適化してコピー
       * 3. 元ファイルを新ファイルで置換
       *
       * 【await の必要性】
       * VACUUM操作は時間がかかるため、完了を待機
       * 他の処理との競合を避ける
       */
      await this.db.exec('VACUUM');

      /**
       * VACUUM完了の確認ログ
       *
       * 【ログの重要性】
       * - メンテナンス作業の完了確認
       * - 運用ログでの作業履歴記録
       * - パフォーマンス改善の効果測定
       */
      logger.info('Database vacuum completed');

      /**
       * エラーハンドリング
       */
    } catch (error) {
      /**
       * VACUUM失敗のログ出力
       *
       * 【考えられるエラー原因】
       * - ディスク容量不足（2倍の容量が必要）
       * - ファイルアクセス権限の問題
       * - データベースファイルの破損
       * - 他のプロセスによるファイルロック
       */
      logger.error('Database vacuum failed:', error);

      /**
       * カスタムエラーとして再投げ
       *
       * 【なぜ再投げ？】
       * VACUUM失敗は重要な問題のため、呼び出し元に明確に通知
       * メンテナンス処理の失敗として適切な対応を促す
       */
      throw new DatabaseError('Failed to vacuum database', error);
    }
  }

  /**
   * データベースの統計情報を取得
   *
   * 【このメソッドの役割】
   * データベースの現在の状態を数値で把握する
   * 1. ファイルサイズの取得
   * 2. テーブル数のカウント
   * 3. インデックス数のカウント
   * 4. 接続状態の確認
   *
   * 【使用用途】
   * - 運用監視ダッシュボード
   * - パフォーマンスモニタリング
   * - デバッグ情報の収集
   * - システムヘルスチェック
   *
   * 【戻り値の型定義】
   * Promise<{
   *   dbSize: number;           // データベースファイルサイズ（バイト）
   *   tableCount: number;       // テーブル数
   *   indexCount: number;       // インデックス数
   *   connectionStatus: boolean; // 接続状態
   * }>
   */
  async getStats(): Promise<{
    dbSize: number;
    tableCount: number;
    indexCount: number;
    connectionStatus: boolean;
  }> {
    try {
      /**
       * 初期化状態の確認
       *
       * 【なぜ例外を投げる？】
       * 統計情報取得は明示的な情報アクセスのため、
       * 未初期化は明確にエラーとして扱う
       */
      if (!this.db) {
        throw new DatabaseError('Database not initialized');
      }

      /**
       * データベースファイルサイズの取得
       *
       * 【三項演算子 とは？】
       * 条件 ? 真の値 : 偽の値
       * if-else文を簡潔に書ける書法
       *
       * 【this.dbPath === ':memory:' の意味】
       * インメモリデータベースの場合の分岐
       * インメモリデータベースにはファイルがないためサイズは0
       *
       * 【fs.statSync(this.dbPath).size とは？】
       * - fs.statSync(): ファイルの統計情報を同期的に取得
       * - .size: ファイルサイズ（バイト単位）
       * - 同期処理を使用する理由：ファイルサイズ取得は高速なため
       */
      const dbSize = this.dbPath === ':memory:' ? 0 : fs.statSync(this.dbPath).size;

      /**
       * テーブル数のカウント
       *
       * 【sqlite_master テーブルとは？】
       * SQLiteのシステムテーブル（メタデータテーブル）
       * データベース内の全てのオブジェクト情報を格納
       *
       * 【type='table' の意味】
       * オブジェクトタイプがテーブルのもののみを結果とする
       * 他には index、view、trigger などがある
       *
       * 【COUNT(*) とは？】
       * 条件にマッチするレコード数をカウントするSQL関数
       */
      const tables = await this.db.all(
        "SELECT COUNT(*) as count FROM sqlite_master WHERE type='table'"
      );

      /**
       * インデックス数のカウント
       *
       * 【インデックスとは？】
       * データベースの検索性能を向上させるデータ構造
       * 特定のカラムでの検索を高速化
       *
       * 【type='index' の意味】
       * オブジェクトタイプがインデックスのもののみをカウント
       */
      const indexes = await this.db.all(
        "SELECT COUNT(*) as count FROM sqlite_master WHERE type='index'"
      );

      /**
       * 接続状態の確認
       *
       * 【なぜヘルスチェックを呼び出す？】
       * 統計情報に加えてリアルタイムの接続状態を取得
       * 数値情報だけでは判断できない接続品質を確認
       */
      const connectionStatus = await this.healthCheck();

      /**
       * 統計情報オブジェクトの返却
       *
       * 【オブジェクトリテラル記法】
       * { キー: 値 } の形式でオブジェクトを作成
       * 複数の関連する情報をまとめて返す
       *
       * 【tables[0].count の意味】
       * - tables: SQLクエリ結果の配列
       * - [0]: 最初の結果レコード
       * - .count: COUNT(*)の結果カラム
       * COUNTクエリは必い1件の結果を返すため[0]でアクセス可能
       */
      return {
        dbSize,
        tableCount: tables[0].count,
        indexCount: indexes[0].count,
        connectionStatus,
      };

      /**
       * エラーハンドリング
       */
    } catch (error) {
      /**
       * 統計情報取得失敗のログ出力
       *
       * 【考えられるエラー原因】
       * - ファイルアクセス権限の問題
       * - データベース接続の問題
       * - sqlite_masterテーブルの破損
       * - システムリソースの不足
       */
      logger.error('Failed to get database stats:', error);

      /**
       * カスタムエラーとして再投げ
       *
       * 【なぜ再投げ？】
       * 統計情報の取得失敗はシステムの問題を示す可能性が高い
       * 呼び出し元で適切なエラー処理やユーザー通知が必要
       */
      throw new DatabaseError('Failed to get database statistics', error);
    }
  }

  /**
   * 期限切れキャッシュデータのクリーンアップ
   *
   * 【このメソッドの役割】
   * 1. 期限切れのキャッシュデータを自動削除
   * 2. データベースサイズの節約
   * 3. 古いデータによるパフォーマンス低下の防止
   *
   * 【実行タイミング】
   * - 定期的なメンテナンス処理（例：毎日1回）
   * - アプリケーション起動時
   * - パフォーマンス問題が発生した時
   *
   * 【TTL（Time To Live）とは？】
   * データの有効期限（生存時間）
   * 期限を超えたデータは無効とみなして削除
   */
  async cleanupExpiredCache(): Promise<void> {
    try {
      /**
       * 初期化状態の確認
       *
       * 【なぜ例外を投げる？】
       * キャッシュクリーンアップはデータを削除する操作のため、
       * 未初期化は明確にエラーとして扱う
       */
      if (!this.db) {
        throw new DatabaseError('Database not initialized');
      }

      /**
       * 期限切れキャッシュエントリの削除
       *
       * 【SQLクエリの説明】
       * DELETE FROM issues WHERE expires_at < datetime("now")
       * - DELETE FROM issues: issuesテーブルからレコードを削除
       * - WHERE expires_at < datetime("now"): 条件指定
       *   - expires_at: 期限日時カラム
       *   - datetime("now"): 現在日時を取得するSQLite関数
       *   - <: 「未満」を表す比較演算子
       *
       * 【クエリの意味】
       * 「期限日時が現在時刻より古いレコードを全て削除」
       *
       * 【db.run() とは？】
       * SQLコマンドを実行し、実行結果を返すメソッド
       * INSERT、UPDATE、DELETE系のコマンドで使用
       */
      const result = await this.db.run('DELETE FROM issues WHERE expires_at < datetime("now")');

      /**
       * 削除結果のログ出力
       *
       * 【result.changes とは？】
       * SQLコマンドによって影響を受けたレコード数
       * DELETE文の場合は削除されたレコード数
       *
       * 【&& 演算子の使用理由】
       * result.changesがundefinedまたは0の場合はログ出力をスキップ
       * ショートサーキットで無駄なログを避ける
       *
       * 【ログの重要性】
       * - メンテナンス作業の結果確認
       * - キャッシュの使用状況把握
       * - パフォーマンス改善の効果測定
       */
      if (result.changes && result.changes > 0) {
        logger.info(`Cleaned up ${result.changes} expired cache entries`);
      }

      /**
       * エラーハンドリング
       */
    } catch (error) {
      /**
       * キャッシュクリーンアップ失敗のログ出力
       *
       * 【考えられるエラー原因】
       * - データベースロック（他の操作との競合）
       * - テーブル構造の問題（issuesテーブルが存在しない）
       * - ファイルアクセス権限の問題
       * - ディスク容量不足（WALファイル書き込み時）
       */
      logger.error('Cache cleanup failed:', error);

      /**
       * カスタムエラーとして再投げ
       *
       * 【なぜ再投げ？】
       * キャッシュクリーンアップの失敗はシステムのパフォーマンスに影響
       * 定期的なメンテナンス処理の失敗として適切な対応を促す
       */
      throw new DatabaseError('Failed to cleanup expired cache', error);
    }
  }
}

// ==================================================
// シングルトンパターンの実装
// ==================================================

/**
 * シングルトンインスタンス変数
 *
 * 【シングルトンパターンとは？】
 * アプリケーション全体で一つのインスタンスのみ作成する設計パターン
 * 複数の場所からアクセスしても常に同じオブジェクトを返す
 *
 * 【なぜシングルトン？】
 * - データベース接続の一元管理
 * - リソース使用量の制限（複数接続の防止）
 * - 設定の一貫性保証
 * - パフォーマンスの向上（接続の再利用）
 *
 * 【初期値null の理由】
 * 最初はインスタンスが存在しない状態
 * 初回アクセス時に遅延初期化（Lazy Initialization）を実行
 */
let dbManager: DatabaseManager | null = null;

/**
 * データベースマネージャーのシングルトンインスタンスを取得
 *
 * 【この関数の役割】
 * 1. シングルトンインスタンスの管理
 * 2. 初回アクセス時の自動インスタンス作成
 * 3. 環境変数からの設定値取得
 * 4. アプリケーション全体での統一アクセス
 *
 * 【使用例】
 * const db = getDatabaseManager();
 * await db.initialize();
 *
 * 【戻り値】
 * DatabaseManager インスタンス（常に同じオブジェクト）
 */
export function getDatabaseManager(): DatabaseManager {
  /**
   * インスタンス存在チェックと遅延初期化
   *
   * 【遅延初期化（Lazy Initialization）とは？】
   * オブジェクトの作成を実際に必要になるまで遅延させる手法
   * メモリ使用量の削減とアプリケーション起動時間の短縮
   *
   * 【! 演算子（論理NOT）の使用】
   * !dbManager → dbManagerがnull/undefinedの場合にtrue
   */
  if (!dbManager) {
    /**
     * データベースファイルパスの取得
     *
     * 【環境変数の優先順位】
     * 1. process.env.DATABASE_PATH: 環境変数で指定されたパス
     * 2. './data/bot.db': デフォルトパス
     *
     * 【|| 演算子の使用】
     * 左側がfalsy（null, undefined, ''など）の場合、右側の値を使用
     * 環境変数が設定されていない場合のフォールバック処理
     *
     * 【なぜ環境変数を使う？】
     * - 環境（開発・本番）ごとの設定変更
     * - セキュリティ（パスをコードに直接書かない）
     * - デプロイ時の柔軟な設定変更
     */
    const dbPath = process.env.DATABASE_PATH || './data/bot.db';

    /**
     * 新しいDatabaseManagerインスタンスの作成
     *
     * 【new キーワード】
     * クラスからオブジェクト（インスタンス）を作成
     * コンストラクタが自動実行されて初期設定が行われる
     *
     * 【インスタンス変数への代入】
     * 作成したインスタンスをモジュールレベルの変数に保存
     * 次回のアクセス時には同じインスタンスを返すため
     */
    dbManager = new DatabaseManager(dbPath);
  }

  /**
   * 既存または新規作成されたインスタンスを返却
   *
   * 【シングルトンの保証】
   * 何度この関数を呼び出しても、常に同じオブジェクトが返される
   * アプリケーション全体でデータベース接続が統一される
   */
  return dbManager;
}

/**
 * データベースの初期化処理
 *
 * 【この関数の役割】
 * 1. シングルトンインスタンスの取得
 * 2. データベースの初期化実行
 * 3. アプリケーション起動時の簡易セットアップ
 *
 * 【使用タイミング】
 * - アプリケーション起動時
 * - サーバー開始前の初期化処理
 * - テスト環境のセットアップ
 *
 * 【async/await の使用】
 * 初期化処理は非同期（ファイル操作、DB接続）のため、
 * 完了を待ってから次の処理に進む
 */
export async function initializeDatabase(): Promise<void> {
  /**
   * シングルトンインスタンス取得と初期化実行
   *
   * 【メソッドチェーンパターン】
   * 1. getDatabaseManager(): インスタンス取得
   * 2. db.initialize(): 初期化メソッド呼び出し
   *
   * 【なぜ分離して記述？】
   * 可読性の向上とデバッグの容易さ
   * インスタンス取得と初期化を明確に分離
   */
  const db = getDatabaseManager();
  await db.initialize();
}

/**
 * データベース接続の終了処理
 *
 * 【この関数の役割】
 * 1. アクティブな接続の適切な終了
 * 2. シングルトンインスタンスのリセット
 * 3. リソースの完全な解放
 * 4. アプリケーション終了時のクリーンアップ
 *
 * 【使用タイミング】
 * - アプリケーション終了時
 * - サーバーシャットダウン時
 * - テスト終了後のクリーンアップ
 * - エラー発生時の復旧処理
 *
 * 【重要性】
 * 適切な終了処理により、データ破損やリソースリークを防ぐ
 */
export async function closeDatabase(): Promise<void> {
  /**
   * インスタンス存在チェックと終了処理
   *
   * 【なぜnullチェック？】
   * 未初期化または既に終了済みの場合は処理をスキップ
   * 重複した終了処理による予期しないエラーを防ぐ
   */
  if (dbManager) {
    /**
     * データベース接続の適切な終了
     *
     * 【close() メソッドの処理内容】
     * - トランザクションのコミット/ロールバック
     * - ファイルハンドルの解放
     * - WALファイルのチェックポイント実行
     * - メモリキャッシュのフラッシュ
     *
     * 【await の必要性】
     * 終了処理が完全に完了してから次の処理に進む
     * 不完全な終了処理によるデータ破損を防ぐ
     */
    await dbManager.close();

    /**
     * シングルトンインスタンスのリセット
     *
     * 【dbManager = null の意味】
     * - シングルトンパターンのリセット
     * - 次回アクセス時の再初期化を可能にする
     * - メモリリークの防止
     * - ガベージコレクションの促進
     *
     * 【なぜリセットが必要？】
     * 閉じられた接続オブジェクトを参照し続けることで、
     * 誤った操作や予期しないエラーを防ぐ
     */
    dbManager = null;
  }
}
